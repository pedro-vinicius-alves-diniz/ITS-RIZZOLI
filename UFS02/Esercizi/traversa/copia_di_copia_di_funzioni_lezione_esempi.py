# -*- coding: utf-8 -*-
"""Copia di Copia di FUNZIONI_Lezione_Esempi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SBUPmUA22RQkBJUoBwKBAZ7ccO6rggp6

# Le Funzioni

### Definizione

Il blocco di codice in cui si definisce una funzione ha la seguente struttura:

def nome_funzione(input1,input2):

    #corpo della funzione: qui si fa qualcosa ... ...
    
    return valore_restituito #(anche nulla oppure più valori)

In pratica:
"""

#definisco una funzione che accetta un parametro e ritorna un valore
def quadrato(a):
    b = a**2
    return b

"""Da notare:
- il blocco di codice inizia con def
- dopo def segue, sulla stessa riga tra parentesi tonde, la lista dei parametri separati da virgole
- segue,sulla stessa riga, il carattere :
- dopo i due punti segue il corpo della funzione che, in genere, e' a un (1) livello di indentazione superiore
- la funzione termina con l'istruzione return, seguita eventualmente dai valori restituiti
- Terminata la funzione si scende di un livello nell indentazione

### Esecuzione
definire una funzione non vuol dire eseguirla!!
"""

# Chiamata della Funzione
num = 15
quadrato = quadrato(num)

print(quadrato)

"""## Passaggio di argomenti a una funzione

Abbiamo visto solo una tipologia di passaggio di argomenti a funzioni. In realta' ne esistono 4 (come vedremo l'ordinamento della seguente lista e' significativo):
- I. per posizione
- II. per nome
- III. per posizione in numero variabile
- IV. per nome in numero variabile

"""

def funz(a,b,c,d):
        """Funzione per prova passaggio argomenti """
        print('-'*15)
        print('a = ',a)
        print('b = ',b)
        print('c = ',c)
        print('d = ',d)
        return

"""### 1) per posizione"""

#si associa un valore ad ogni parametro in base all'ordine con cui passo gli argomenti:
funz(1,'ciao',3.55,[1,2,3,4])

"""Per come e' definita la funzione devo sempre specificare 4 argomenti:

"""

funz(3,4,5)

"""### 2) per nome

Uso la sintassi nomeparametro = argomento In questo caso gli argomenti passati per nome possono essere ordinati a piacere:

"""

funz(a=33,b=3,c=2,d=1)
funz(d=1,c=2,b=3,a=33)

"""Posso anche mischiare il passaggio per posizione e quello per nome ma solo in modo ordinato: prima quelli per posizione e poi quelli per nome.

"""

#questo lo posso fare, prima per posizione, poi per nome
funz(1, 2, d=4, c=3)

funz(1, 2, a=4, c=3)

"""di contro non posso passare parametri per nome prima di parametri posizionali

"""

funz(a=1,2,3,4)

"""### 3) per posizione in numero variabile (*args)

Posso definire una funzione in modo che accetti un numero variabile di argomenti passati per posizione:
"""

def funz2(*args):
    print('-'*15)

    for arg  in args:
        print(arg)

"""vediamo un esempio di utilizzo:

"""

funz2()
funz2(1)
funz2(1,2,3)
funz2(1,[2,3],'ciao')

"""La notazione *args e' uno standard in Python ma l'interprete accetterebbe qualsiasi nome dopo l'asterisco."""

def funz3(*argomenti):
    print(type(argomenti))
    print('-'*15)
    for arg in argomenti:
        print(arg)


funz3(1,2,3,4,5,'ciao')

"""Python interpreta il nome che segue l'asterisco come una tupla! Non posso passare nessun argomento per nome a una funzione come funz3!!!

"""

funz3((2,3))

"""### 4) per nome in numero variabile (**kwargs)

Uso il doppio asterisco nella definizione della funzione:
"""

def funz4(**kwargs):
    print(type(kwargs))
    print(kwargs)
    return


funz4(b=2, a=1)

funz4(f=2,chiave=5)

"""Quindi kwargs (o meglio il nome che segue il doppio asterisco) e' un dizionario che contiene come chiavi i nomi dei parametri e come valori il valori del parametro associato"""

def funz4(**kwargs):
    print('-'*15)
    for key in kwargs:
        print(key,'=',kwargs[key])

funz4(a=1,b=2)
#funz4(1,b=2)

"""Non posso passare alcun argomento per posizione a funz4

"""

funz4(1,b=2)

"""### 3+4) funzioni che accettano un numero variabile di argomenti per posizione e per nome (__*args__, **kwargs)

combinando le due ultime opzioni e' possibile definire funzioni che accettano un numero qualsiasi di argomenti sia per posizione sia per nome
"""

def funz5(*args,**kwargs):
    print('-'*20)

    #itero sugli argomenti posizionali
    for i,arg in enumerate(args):
        print('posizionale n.{0} = {1}'.format(i+1,arg))

    #itero sugli argomenti passati per nome
    for key in kwargs:
        print(key,' = ',kwargs[key])

funz5(1)

funz5(1,2,a=3)

funz5('ciao',1,a=4.3,b=[1,2],c={1:2,'a':3})

"""### Gli operatori di assegnamento 'splat' (o starred assignment)

In Python 3, la possibilità di lavorare con un numero indefinito di parametri è stata estesa anche all'operatore di assegnamento oltre che agli argomenti delle funzioni. Vediamo come:

"""

## STARRED ASSIGNMENT ##

l = range(5)
a,*b =  l

print('a=',a)
print('b=',b)

"""l'espressione di assegnamento sopra è equivalente a:

"""

a = l[0]
b = list(l[1:])

print('a=',a)
print('b=',b)

"""l'operatore di assegnamento starred può essere usato nello stesso contesto anche nei seguenti modi

"""

*a,b = range(5)
print('a=',a)
print('b=',b)

a,*b,c = range(5)
print('a=',a)
print('b=',b)
print('c=',c)

a,*b,c = range(10)
print('a=',a)
print('b=',b)
print('c=',c)

"""## Modifica del valore di una variabile passata come parametro ad una funzione (passaggio per valore/argomento)

E' possibile modificare il valore di una variabile passata come parametro ad una funzione in modo che tale modifica permanga anche quando la funzione e' terminata?

A tale scopo alcuni linguaggi (come il C++) introducono la distinzione tra passaggio per valore e per riferimento (puntatori).

Anche in python esiste questa distinzione anche se meno esplicita e più sottile.

Cio' nondimeno esiste una regola chiara riassumibile nei seguenti punti:
- I parametri passati alla funzione sono riferimenti a oggetti e non gli oggetti stessi.
- se il parametro e' di tipo **NON-MUTABLE** la funzione (ma non solo lei) non potra' modificare in-place il valore della variabile (*).
- se il parametro e' di tipo **MUTABLE** la funzione puo' EVENTUALMENTE modificare in-place il valore della variabile in modo che tale modifica permanga una volta che la funzione e' terminata.

(*) sara' eventualmente possibile assegnare un nuovo oggetto al nome della variabile passata come parametro, ma per vedere questo dovremo riferirci al paragrafo dedicato alla __Modifica di variabili globali in funzioni__

vediamo un esempio:
"""

def prova_a_modificare(x,y,z):
    #associo un nuovo oggetto al nome x
    x = 23
    #modifico in-place l'oggetto associato al nome y
    y.append(2)
    #associo un nuovo oggetto al nome z
    z = [1,2,3]

    print('-'*20)
    print('x = ',x)
    print('y = ',y)
    print('z = ',z)
    print('-'*20)

"""usiamo la funzione definita sopra"""

a = 1      # int,  non-mutable
b = ['b']  # list, mutable
c = ['c']  # list, mutable

print('prima')
print('a = ',a)
print('b = ',b)
print('c = ',c)

# Qui stamperà i parametri dal'interno della funzione
prova_a_modificare(a,b,c)

print('dopo')
print('a = ',a)
print('b = ',b)
print('c = ',c)

"""### PARAMETRI DI DEFAULT

I parametri di una funzione, possono anche avere un valore di default, che viene assunto quando non diversamente specificato
"""

def funz6(a=-1):
    print('a = ',a)
    return

#se non passo alcun argomento il parametro assume il valore di default
funz6()
funz6(10)

"""### I parametri di default sono valutati nel momento in cui la funzione e' definita

... e non ogni volta che la funzione e' eseguita.

Cio' e' evidente con il seguente esempio:

"""

#definisco una variabile myx
myx = 10

#il parametro di default viene valutato quando myx vale 10
def percinque(x = myx):
    return x*2

#richiamo lafunzione senza passarle il parametro
print(percinque())

#se adesso assegno un nuovo valore a myx
myx=1000

# richiamo la funzione
print(percinque())

"""### Attenzione ai parametri di default mutable!!

In relazione a quanto detto sopra si puo' capire perche' vale la raccomandazione che ai parametri di default dovrebbero essere assegnati oggetti NON mutable. Vediamo un esempio di cosa puo' succedere altrimenti

definisco una funzione che determina gli elementi positivi in una sequenza e li aggiunge ad una lista
"""

def positivi(lista , pos=[]):
    for v in lista:
        if v>0:
            pos.append(v)
    return pos

"""La prima chiamata a positivi sembra funzionare bene:

"""

positivi([-1,3,4,-22,0])

"""ma la seconda chiamata...

"""

positivi([1000,-2,-3,55.2])

"""### Questo accade perche' l'istruzione pos=[ ] non viene eseguita ogni volta che la funzione e' usata ma solo una volta, quando la funzione e' definita!!!

Nel caso illustrato il parametro di default e' una lista (MUTABLE) che pero' non viene svuotata ad ogni chiamata alla funzione. Piuttosto la lista mantiene memoria dei risultati ottenuti in tutte le chiamate precedenti.

Segue una possibile soluzione per risolvere il problema illustrato nel precedente esempio:
"""

def positivi(lista , pos=None):
    if pos == None:
        pos =  []
    for v in lista:
        if v>0:
            pos.append(v)
    return pos

pos1 = positivi([-1, 3, 4, -22, 0])
print(pos1)

pos2 = positivi([1000,-2,-3,55.2])
print(pos2)

pos3 = positivi([121.1,-22,-33,], pos2[:])
print(pos3)

#cosa succede se tolgo [:]??
pos3 = positivi([121.1,-22,-33,])
print(pos3)

"""## Il tipo di dato 'funzione'
Dopo la definizione di una funzione il nome della funzione si riferisce ad un' "istanza" della funzione.

In altre parole una funzione e' un tipo di dato predefinito.

Se si usa il nome di una funzione senza le parentesi l'interprete ci dice che ci stiamo riferendo al nome di una funzione
"""

def quadrato(a):
    return a**2

#non sto usando la funzione!!!!
#sto semplicemente facendo riferimento al suo nome
print(quadrato)

"""In relazione a quanto detto sopra:

"""

type(quadrato)

"""Che e' diverso da:

"""

type(quadrato(2))

# assegno la funzione a una variabile
a = quadrato

# chiamo la funzione quadrato con a
a(2)

"""### Assegnazione del nome di una funzione ad una variabile

Essendo la funzione un tipo di dato, **posso assegnare una funzione (o meglio il suo nome) ad una variabile** e poi usare la variabile (o meglio la funzione alla quale la variabile si riferisce):

"""

q = quadrato

"""è come se avessi attribuito un nuovo nome alla funzione:

"""

q(7)

"""in realtà l'attributo __name__ della funzione mantiene il riferimento al nome assegnato in fase di definizione.

"""

q.__name__

"""### Passaggio di una funzione come parametro ad un'altra funzione

posso passare una funzione come parametro ad un altra funzione:
"""

# Passaggio di una funzione come parametro ad un'altra funzione
def quadrato(a):
    return a**2

def applica_funzione(funzione, argomento):
    """stampa una stringa con
    funzione(argomento)=risultato
    restituisce None (nulla) """

    print(f'sto per usare la funzione {funzione.__name__}()')

    #determino il risultato
    risultato = funzione(argomento)
    #stampo la stringa con il risultato
    print(f'{funzione.__name__}({argomento}) = {risultato}')
    print('fine')
    return  #termino la funzione senza ritornare nulla

a = applica_funzione(quadrato,6.234)

b = applica_funzione(abs,-4.546)

c = applica_funzione(len,range(5))

"""### La ricorsione

In python è molto semplice implementare la ricorsione (una funzione che chiama se stessa).

Vediamo questa tecnica applicata ad un esempio di funzione che implementa l'elevazione a potenza fra numeri interi:
"""

# La ricorsione
def potenzaint(x, y):
    if y == 0:
        return 1
    elif y > 0:
        print('potenzaint({0},{1})'.format(x,y))
        return x*potenzaint(x,y-1)
    else:
        print('potenzaint({0},{1})'.format(x,y))
        return 1/x*potenzaint(x,y+1)

potenzaint(2,4)

potenzaint(2,-4)

"""### Annidamento di funzioni

In una funzione possono essere utilizzate altre funzioni, definite altrove.

Le funzioni però possono essere annidate cioè definite una dentro l'altra, anche a più livelli.

"""

# Annidamento di funzioni

#inizio definizione f1
def f1():

    #####inizio definizione f2
    def f2():
        #questa funzione viene ridefinita ogni
        #volta che f1 viene utilizzata
        print('sono in f2')
        return
    #####fine definizione f2

    print('sono in f1')

    # in f1 posso usare f2
    # f2 e' utilizzata qui
    # e non nel momento della definizione
    f2()
#fine definizione f1


#uso f1 e quindi anche f2
f1()

"""visto che f2 e' definita in f1 ne consegue che fuori da f1 NON posso usare f2

"""

# chiamata a f2 fuori dallo scope della f1 nella quale è definita
f2()

"""### Attributi di una funzione

In un precedente esempio abbiamo usato l'attributo funzione.__name__ vediamo se ce ne sono altri

"""

# Attributi di una funzione, dir restituisce la una lista
dir(applica_funzione)

"""Vediamo cosa c'e' in applica_funzione.__doc__:"""

print(applica_funzione.__doc__)

help(applica_funzione)

"""dentro applica_funzione abbiamo usato funzione.__name__ cioe' l'attributo che contiene il nome della funzione:

"""

quadrato.__name__

"""Posso anche aggiungere attributi alle funzioni:"""

quadrato.nota='non serve a nulla...'

"""L'attibuto e' stato aggiunto:"""

print('nota' in dir(quadrato))

print(dir(quadrato))

"""e inoltre lo si ritrova in:

"""

quadrato.__dict__

"""Tutte le funzioni hanno l'attributo __call__ che significa che possono essere 'chiamate' con la sintassi nomefunzione(argomentifunzione)

## Gli Scope (chi vede cosa)

Per **'Scope'** di una variabile, si intende l'ambito in cui la variabile puo' essere usata

**Lo scope di una variabile e' determinato da dove questa viene definita.**

In particolare, in relazione ad una generica funzione:

- se una variabile e' definita nella funzione stessa si dice locale alla funzione
- se una variabile e' definita in una funzione che racchiude la funzione alla quale ci si riferisce (enclosing def) la funzione si dice **nonlocale alla funzione**
- se una variabile e' definita all'esterno di tutte le funzioni, e' detta variabile **globale**

La questione degli scope ha rilevanza a proposito:
- dove posso usare una variabile
- cosa succede se assegno lo stesso nome a variabili di contesti diversi
- dove Python cerca le variabili in base al loro nome ed al punto di definizione

vediamo cosa significa con degli esempi.

### Uso di variabili locali che hanno lo stesso nome di variabili globali

definisco una funzione che, al suo interno definisce una variabile X
"""

# Gli Scope (chi vede cosa)

#Uso di variabili locali che hanno lo stesso nome di variabili globali
def func(X):
    #X e' locale alla funzione
    X = 'ciao'
    print('X = ',X)
    #return X

## ESEGUO ##
#definisco una variabile X globale
X = 10

print('X prima della chiamata = ',X)
func(X)
print("X dopo l'esecuzione di func = ",X)

"""dentro func uso la X locale (X locale nasconde X globale) fuori da func uso X globale

### Uso di variabili globali in funzioni
Se in una funzione si usa una variabile (in una espressione, a destra dell'operatore = ad esempio) che non e' stata definita nella funzione stessa l'interprete cerca la definizione della variabile all'esterno della funzione stessa.

In generale una variabile come quella descritta si dice una 'variabile libera' (free variable) nel contesto della funzione.

Nel seguente caso la funzione fun una variabile X che e' definita esternamente a tutte le funzioni.
"""

# Uso di variabili globali in funzioni
def fun(Y):
    #X e' globale anche se non esplicitato
    global X
    X = X + Y
    #return X


# siamo nel Main
#variabile globale cioè visibile dentro e fuori da fun
X = 10

fun(X) #Y assume il valore 1 ed e' locale a fun
#print(num)

print('X globale:', X)



"""### Modifica di variabili globali in funzioni (uso della parola riservata global)

Nell'esempio precedente ho usato la variabile globale X.

Ma come fare se io voglio modificare una variabile globale all'interno di una funzione?

Considerando uno degli esempi precedenti, risulta evidente come non posso semplicemente digitare X = nuovovalore perche' in tal caso creerei una variabile locale che 'maschera' la variabile globale e non modificherei la variabile globale stessa. Vediamo un altro esempio a proposito.

"""

# Modifica di variabili globali in funzioni (uso della parola riservata global)
#definisco una funzione che, al suo interno definisce una variabile X
def func():
    #X e' locale alla funzione
    X = 'ciao'
    print('X durante la chiamata a funzione = ',X)

#definisco una variabile X globale
X = 10

#stampo X globale
print('X prima della chiamata a funzione = ',X)

#uso la funzione che al suo interno stampa la X a lei locale
func()

#stampo X globale
print('X dopo della chiamata a funzione = ',X)

"""In questi casi si usa la keyword global che specifica esplicitamente che stiamo operando su una variabile globale. L'esempio precedente e' modificato semplicemente aggiungendo 'global X' all'inizio della funzione.

"""

#definisco una funzione che, al suo interno definisce una variabile X
def func():
    #dichiaro che X e' quella globale!!!!!!!
    global X
    X = 'ciao'
    print('X durante la chiamata a funzione = ',X)

#definisco una variabile X globale
X = 10

#stampo X globale
print('X prima della chiamata a funzione = ',X)

#uso la funzione che al suo interno stampa la X a lei locale
func()

#stampo X globale
print('X dopo della chiamata a funzione = ',X)

# NOTA: una variabile dichiarata global all'interno di una funzione
# non puo' essere anche uno dei parametri della funzione stessa.
def func(X):
    global X
    X = 'ciao'
    print('X durante la chiamata a funzione = ',X)

"""### Uso di variabili nonlocali in funzioni

Si è già detto che una variabile non locale è una variabile definita in uno scope esterno alla funzione di riferimento ma comunque non a livello globale.

Il seguente esempio tratta di tre variabili X,Y,Z definite sia a livello globale, sia all'interno di due funzioni annidate.

La prima versione evidenzia la visibilità delle variabili all'interno delle funzioni.

Nella seconda versione dell'esempio si illustra l'effetto della parola riservata nonlocal.

"""

#definisco una funzione con una funzione annidata
def funzione_esterna():
    def funzione_interna():
        #(8)
        X = 'X funzione interna'
        #(9),(10)
        print('-3-',X,Y,Z)
        # terza (in ordine di esecuzione) chiamata a print
        return # fine DEFINIZIONE funzione interna
    #(4)
    X = 'X funzione esterna'
    Y = 'Y funzione esterna'
    #(5),(6)
    print('-2-',X,Y,Z)# seconda chiamata a print
    #(7)
    funzione_interna()

    print('-4-',X,Y,Z)# quarta chiamata a print
    return #fine funzione esterna

## ESEGUO LE FUNZ ##

#(1)
X = 'X globale'
Y = 'Y globale'
Z = 'Z globale'

#(2)
print('-1-',X,Y,Z)# prima chiamata a print

#(3)
funzione_esterna()
print('-5-',X,Y,Z)# prima chiamata a print

"""- (1) definisco le 3 variabili globali X,Y,Z
- (2) stampo le 3 variabili globali X,Y,Z (prima chiamata a print)
- (3) chiamo funzione esterna (non ci interessa qui specificare quando la funzione e' stata definita)
- (4) definisco le 2 variabili X e Y locali al contesto di chiamata
- (5) stampo le 3 variabili X,Y,Z (seconda chiamata a print)
- (6) le variabili stampate sono la Z globale e le X e Y locali
- (7) chiamo la funzione interna
- (8) definisco la variabile X locale
- (9) stampo le 3 variabili (terza chiamata a print)
- (10) le variabili stampate sono la Z globale la Y nonlocale (definita in funzione esterna) e la X locale

### nonlocal

esiste una parola chiave (nonlocal) analoga a global che permette di dichiarare esplicitamente che si sta operando su una variabile libera non-locale e quindi modificarla.
"""

#definisco una funzione con una funzione annidata
def funzione_esterna():

    def funzione_interna():
        #(8)
        nonlocal X
        X = 'X funzione interna' #agisco sulla X della funzione esterna!!!
        #(9),(10)
        print('-3-',X,Y,Z)
        return

    #(4)
    X = 'X funzione esterna'
    Y = 'Y funzione esterna'
    #(5),(6)
    print('-2-',X,Y,Z)
    #(7)
    funzione_interna()
    #(7)
    print('-4-',X,Y,Z)######### genera un risultato diverso dall'esempio precedente
    return

"""sotto si può vedere l'effetto dell'uso di nonlocal nella chiamata -4- a print

"""

#(1)
X = 'X globale'
Y = 'Y globale'
Z = 'Z globale'
#(2)
print('-1-',X,Y,Z)# prima chiamata a print
#(3)
funzione_esterna()
print('-5-',X,Y,Z)# prima chiamata a print

"""## Esercizi"""

'''
 funzione_1
'''
# definire una funzione che accetta quattro argomenti con nome
# a1,a2,a3,a4
# e restituisce una lista che contiene i quattro argomenti nell'ordine invertito
#
# Esempio:
#   >>>funzione_1('1',2,'ciao',4.55)def8
#   [4.55,'ciao',2,'1']

def funzione01(a1, a2, a3, a4):
  return [a4, a3, a2, a1]

print(funzione01(1, 2, 3, 4))

'''
 funzione_2
'''
# definire una funzione che usa al suo interno la precedente funzione_1() e che:
#
# - accetta quattro argomenti con i seguenti nomi ed ordine b1,b2,b3,b4
# - associa i parametri a della prec. funz. ai parametri
#   b nel seguente modo:  a1=b1 , a2=b2 , a3=b3 , a4=b4
# - se sono passati solo 3 parametri usa per b4 il valore 0
# suggerimento:
# - nel corpo della nuova funzione_2 usare la funzione soluzione
#   del precedente esercizio con argomenti passati per nome
# - negli argomenti della nuova funzione usare un default per b4
#
# Esempi:
#   >>> funzione_2('1',2,'ciao',4.55)
#   [4.55, 'ciao', 2, '1'])
#   >>> funzione_2('1',2,'ciao')
#   [0, 'ciao', 2, '1'])

def funzione_2(b1, b2, b3, b4 = 0):
  return [b4, b3, b2, b1]

funzione_2(1, 2, 'ciao')

'''
Funzione_3
'''

# definire una funzione che accetta un numero variabile
# di parametri passati per posizione/valore e che restituisce una lista
# che ha come primo elemento il numero di parametri (la sua lunghezza) e a seguire
# i parametri passati alla funzione
# Esempi:
#   >>> funzione_3('a','b','c')
#   [3,'a','b','c']

def funzione_3(*args):
  lista = [len(args),]
  for i in args:
    lista.append(i)

  return lista

print(funzione_3("pedro", "cintia","sonia", 'lucas'))

'''
funzione_04
'''
# definire una funzione che accetta un numero variabile
# di parametri passati per posizione (almeno 1) e che restituisce la 'somma' di tutti gli argomenti (parametri di input)

# Esempi:
#   >>> funzione_4('a','b','c',' prova')
#   'abc prova'
#   >>> funzione_4(1,2,3)
#   6

def funzione_04(*args):
  risultato = ""
  for i in args:
    risultato += i
  return risultato

funzione_04('a', 'b', 'c', ' prova')

'''
 funzione_5
'''
# definire una funzione che accetta un numero variabile
# di parametri passati per nome e restituisce una lista
# dove il primo elemento è il numero di parametri e a seguire ci sono delle tuple di due elementi
# il cui primo elemento è una stringa che contiene il nome del parametro ed il secondo contiene il valore del parametro.
# le tuple nella lista sono ordinate per chiave
#
# Esempi:
#   >>> funzione_5(a='a' , b='b' , c='c' ,d=1)
#   [4,('a','a'),('b','b'),('c','c'),('d',1)]
#   >>> funzione_5(x=1,y=2,z=3,k='1')
#   [4,('x',1),('y',2),('z',3),('k','1')]

lista = []

def funzione_05(**kwargs):
  lista.append(len(kwargs))
  for key in kwargs:
    lista.append((key, kwargs[key]))

  return lista

print(funzione_05(a='a', b='b', c='c', d=1))

'''
 funzione_6
'''
# definire una funzione che accetta come primo argomento
# una generica variabile var seguita da un numero imprecisato di argomenti
# posizionali e da un numero imprecisato di parametri passati per nome
# La funzione restituisce una lista che ha come primo elemento il numero di volte che val
# compare tra gli argomenti posizionali e come secondo numero  il numero di volte che val
# compare tra gli argomenti passati per nome
# Esempi:
#   >>>funzione_6(1,2,3,1,1,1,d=2,c=3,e=1,m=1)
#   [3,2]
#   >>>funzione_6(1,2,3,1,1,1)
#   [3,0]
#   >>>funzione_6(1,d=2,c=3,e=1,m=1)
#   [0,2]

valore = int(input("Scegli un numero per la variabile 'val': "))

def funzione_06(val,*args, **kwargs):
  val_pos = 0
  val_nome = 0

  for i in args:
    if val == i:
      val_pos +=1

  for key in kwargs:
    if kwargs[key] == val:
      val_nome +=1

  return [val_pos, val_nome]

print(funzione_06(valore,2,3,1,1,1,d=2,c=3,e=1,m=1))

'''
 funzione_7(func)
'''

# definire la funzione funzione_7 che data una lista globale di nome L
# applica ai soli elementi pari della lista L una generica funzione 'func'
# passata come unico argomento della lista.
# La funzione restituisce una nuova lista con i valori degli elementi con indice pari
# modificati rispetto alla lista L.

# Esempi:
#   >>>L = [-2,-3,-4,-5,-6,-7]
#   >>>funzione_7(abs)
#   [2,-3,4,-5,6,-7]
#
#   >>>L = list('ciaociao')
#   >>>funzione_7(str.capitalize)
#   ['C','i','A','o','C','i','A','o']

I = [-2,-3,-4,-5,-6,-7]
S = list('ciaociao')


def funzione_7(lista):
  list = []

  for i in range(len(lista)):
    if type(lista[i]) == int:
        if i % 2 == 0:
            lista[i] *= -1
            list.append(lista[i])
        else:
           list.append(lista[i])

    else:
        valore = str(lista[i])
        if i % 2 == 0:
            list.append(valore.capitalize())
        else:
            list.append(valore)



  return list

print(funzione_7(I))
print(funzione_7(S))

'''
 funzione_8(func,L)
'''
# come la precedente ma le modifiche sono effettuate in-place in L, passata come parametro
# e la funzione restituisce il numero degli elementi modificati e la stampa della nuova lista (o vecchia lista modificata)

# Esempi:
#   >>>L = [-2,-3,-4,-5,-6,-7]
#   >>>funzione_8(abs, L)
#   3
#   >>>L
#   [2,-3,4,-5,6,-7]
#
#   >>>L = list('ciaociao')
#   >>>funzione_8(str.capitalize, L)
#   4
#   >>>L
#   ['C','i','A','o','C','i','A','o']

I = [-2,-3,-4,-5,-6,-7]
S = list('ciaociao')


def funzione_7(lista):
  changes = 0
  list = []

  for i in range(len(lista)):
    if type(lista[i]) == int:
        if i % 2 == 0:
            lista[i] *= -1
            list.append(lista[i])
            changes += 1
        else:
           list.append(lista[i])

    else:
        valore = str(lista[i])
        if i % 2 == 0:
            list.append(valore.capitalize())
            changes += 1
        else:
            list.append(valore)

  print(changes)
  print(list)


funzione_7(I)
funzione_7(S)

# esempio codice funzione_8
n = 0
L = list('ciaociao')

# qui chiamo la funzione_8(str.capitalize, L)
newL = list()
for i,v in enumerate(L):
    if i%2 == 0:
        newL.append(L[i].capitalize())
        n += 1
    else:
        newL.append(v)
print(n)
print(newL)

'''
 funzione_9(subs,lista_stringhe,[results])
'''

# cerca l'occorrenza della stringa subs nelle stringhe
# contenute nella lista di stringhe lista_stringhe
# aggiunge le stringhe in cui la ricerca ha dato esito positivo alla lista results
#  che è un parametro opzionale (circondata dalle [] significa opzionale)
# Esempi:
# >>> findsubstrings("pi",['piadina','arpia','prezzemolo','rinpinguare'])
# ['piadina', 'arpia', 'rinpinguare']
# >>> findsubstrings("pi",['Privato','Piacere','tovaglia','carpiato'])
# ['carpiato']
# >>> findsubstrings("pi",['pistone'],['carpiato'])
# ['carpiato', 'pistone']

------------------------
 funzione_10(stringa)
 ------------------------
# Una stringa si dice palindroma quando rimane identica
# leggendola nelle due direzioni (inizio ->fine) (fine ->inizio)
# creare una funzione in grado di riconoscere una stringa palindroma
# Esempi
#  >>> funzione_10("Racecar")
#  True
#  >>> funzione_10("Never")
#  False
#  >>> funzione_10("level")
#  True
#  >>> funzione_10("")
#  True
#  >>> funzione_10("a")
#  True

"""### Le funzioni dovranno essere inserite in un unico script e eseguite nella sezione di test (`if __name__ == '__main__'`) e richiamate nell'ordine. Inserite gestione degli errori di input e qualsiasi altra cosa pensiate sia necessario.

## `if __name__=='__main__':`

- in genere in un modulo (o script .py) si definiscono funzioni o classi.
- c'e' un modo per includere nel modulo anche una sessione di test o di esempi delle funzioni create senza che queste siano eseguite quando il modulo è importato da altri moduli.
- questa sessione di test/esempi sarà eseguita solo quando il modulo viene eseguito come script.

facciamo un esempio con uno script/modulo generico **funzioni.py**, nel quale si è inclusa una sezione di test per chiamare le funzioni al suo interno:
"""

if __name__=='__main__':

    print('-'*10)
    funzione_1()

    print('-'*10)
    funzione_2()

    print('-'*10)
    funzione_3()

"""Se eseguiamo lo script da terminale o eseguiamo il modulo stand alone **la sezione di test viene eseguita!**"""

